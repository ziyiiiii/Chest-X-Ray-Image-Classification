# -*- coding: utf-8 -*-
"""XRay CNN

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vlJ6ZktvMLLNDc-8Kst3oCkoAj8eP7qj

### Start
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import os
import tensorflow as tf
from glob import glob
# %matplotlib inline
import matplotlib.pyplot as plt

!pip install tensorflow==1.6.0-rc1

!pip uninstall keras

import tensorflow as tf
print(tf.__version__)

from google.colab import drive
drive.mount('/content/gdrive')

from google.colab import files
files.upload()  #this will prompt you to upload the kaggle.json

!pip install -q kaggle
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!ls ~/.kaggle
!chmod 600 /root/.kaggle/kaggle.json  # set permission

!kaggle datasets list -s nih-chest

from google.colab import drive
drive.mount('/content/gdrive')

!kaggle datasets download -d nih-chest-xrays/data -p /content/gdrive/My\ Drive/kaggle/lung

!unzip  /content/gdrive/My\ Drive/kaggle/lung/sample.zip

all_xray_df = pd.read_csv('./sample_labels.csv')
all_image_paths = {os.path.basename(x): x for x in 
                   glob(os.path.join('.', 'sample', 'images', '*.png'))}
print('Scans found:', len(all_image_paths), ', Total Headers', all_xray_df.shape[0])
all_xray_df['path'] = all_xray_df['Image Index'].map(all_image_paths.get)
all_xray_df['Patient Age'] = all_xray_df['Patient Age'].map(lambda x: int(x[:-1]))
all_xray_df.sample(3)

all_xray_df['Finding Labels'] = all_xray_df['Finding Labels'].map(lambda x: x.replace('No Finding', ''))
from itertools import chain
all_labels = np.unique(list(chain(*all_xray_df['Finding Labels'].map(lambda x: x.split('|')).tolist())))
all_labels = [x for x in all_labels if len(x)>0]
print('All Labels ({}): {}'.format(len(all_labels), all_labels))
for c_label in all_labels:
    if len(c_label)>1: # leave out empty labels
        all_xray_df[c_label] = all_xray_df['Finding Labels'].map(lambda finding: 1.0 if c_label in finding else 0)
all_xray_df.sample(3)

all_xray_df['disease_vec'] = all_xray_df.apply(lambda x: [x[all_labels].values], 1).map(lambda x: x[0])

from sklearn.model_selection import train_test_split
train_df, valid_df = train_test_split(all_xray_df, 
                                   test_size = 0.25, 
                                   random_state = 2018,
                                   stratify = all_xray_df['Finding Labels'].map(lambda x: x[:4]))
print('train', train_df.shape[0], 'validation', valid_df.shape[0])

!pip install keras==2.1.4

from keras.preprocessing.image import ImageDataGenerator
IMG_SIZE = (128, 128)
core_idg = ImageDataGenerator(samplewise_center=True, 
                              samplewise_std_normalization=True, 
                              horizontal_flip = True, 
                              vertical_flip = False, 
                              height_shift_range= 0.05, 
                              width_shift_range=0.1, 
                              rotation_range=5, 
                              shear_range = 0.1,
                              fill_mode = 'reflect',
                              zoom_range=0.15)

def flow_from_dataframe(img_data_gen, in_df, path_col, y_col, **dflow_args):
    base_dir = os.path.dirname(in_df[path_col].values[0])
    print('## Ignore next message from keras, values are replaced anyways')
    df_gen = img_data_gen.flow_from_directory(base_dir, 
                                     class_mode = 'sparse',
                                    **dflow_args)
    df_gen.filenames = in_df[path_col].values
    df_gen.classes = np.stack(in_df[y_col].values)
    df_gen.samples = in_df.shape[0]
    df_gen.n = in_df.shape[0]
    df_gen._set_index_array()
    df_gen.directory = '' # since we have the full path
    print('Reinserting dataframe: {} images'.format(in_df.shape[0]))
    return df_gen

train_gen = flow_from_dataframe(core_idg, train_df, 
                             path_col = 'path',
                            y_col = 'disease_vec', 
                            target_size = IMG_SIZE,
                             color_mode = 'grayscale',
                            batch_size = 32)

valid_gen = flow_from_dataframe(core_idg, valid_df, 
                             path_col = 'path',
                            y_col = 'disease_vec', 
                            target_size = IMG_SIZE,
                             color_mode = 'grayscale',
                            batch_size = 256) # we can use much larger batches for evaluation
# used a fixed dataset for evaluating the algorithm
test_X, test_Y = next(flow_from_dataframe(core_idg, 
                               valid_df, 
                             path_col = 'path',
                            y_col = 'disease_vec', 
                            target_size = IMG_SIZE,
                             color_mode = 'grayscale',
                            batch_size = 1024)) # one big batch

t_x, t_y = next(train_gen)
fig, m_axs = plt.subplots(4, 4, figsize = (16, 16))
for (c_x, c_y, c_ax) in zip(t_x, t_y, m_axs.flatten()):
    c_ax.imshow(c_x[:,:,0], cmap = 'bone', vmin = -1.5, vmax = 1.5)
    c_ax.set_title(', '.join([n_class for n_class, n_score in zip(all_labels, c_y) 
                             if n_score>0.5]))
    c_ax.axis('off')

!pip install keras --upgrade

from keras.applications.mobilenet import MobileNet
from keras.layers import GlobalAveragePooling2D, Dense, Dropout, Flatten
from keras.models import Sequential
base_mobilenet_model = MobileNet(input_shape =  t_x.shape[1:], 
                                 include_top = False, weights = None)
multi_disease_model = Sequential()
multi_disease_model.add(base_mobilenet_model)
multi_disease_model.add(GlobalAveragePooling2D())
multi_disease_model.add(Dropout(0.5))
multi_disease_model.add(Dense(512))
multi_disease_model.add(Dropout(0.5))
multi_disease_model.add(Dense(len(all_labels), activation = 'sigmoid'))
multi_disease_model.compile(optimizer = 'adam', loss = 'binary_crossentropy',
                           metrics = ['binary_accuracy', 'mae'])
multi_disease_model.summary()

from keras.callbacks import ModelCheckpoint, LearningRateScheduler, EarlyStopping, ReduceLROnPlateau
weight_path="{}_weights.best.hdf5".format('xray_class')

checkpoint = ModelCheckpoint(weight_path, monitor='val_loss', verbose=1, 
                             save_best_only=True, mode='min', save_weights_only = True)

early = EarlyStopping(monitor="val_loss", 
                      mode="min", 
                      patience=3)
callbacks_list = [checkpoint, early]

multi_disease_model.fit_generator(train_gen, 
                                  steps_per_epoch=100,
                                  validation_data = (test_X, test_Y), 
                                  epochs = 1, 
                                  callbacks = callbacks_list)

"""### Here's the start of subsetting by F & AP"""

F = train_df.loc[train_df['Patient Gender'] == 'F']
F_AP = F.loc[F['View Position'] == 'AP']
valid_F = valid_df.loc[valid_df['Patient Gender'] == 'F']
valid_F_AP = valid_F.loc[valid_F['View Position'] == 'AP']

test_X_FAP, test_Y_FAP = next(flow_from_dataframe(core_idg, 
                               valid_F_AP, 
                             path_col = 'path',
                            y_col = 'disease_vec', 
                            target_size = IMG_SIZE,
                             color_mode = 'grayscale',
                            batch_size = 1024)) # one big batch

from keras.callbacks import ModelCheckpoint, LearningRateScheduler, EarlyStopping, ReduceLROnPlateau
weight_path1="{}_weights.best.hdf5".format('xray_class')

checkpoint1 = ModelCheckpoint(weight_path1, monitor='val_loss', verbose=1, 
                             save_best_only=True, mode='min', save_weights_only = True)

early1 = EarlyStopping(monitor="val_loss", 
                      mode="min", 
                      patience=3)
callbacks_list1 = [checkpoint1, early1]

F_AP_gen = flow_from_dataframe(core_idg, F_AP, 
                             path_col = 'path',
                            y_col = 'disease_vec', 
                            target_size = IMG_SIZE,
                             color_mode = 'grayscale',
                            batch_size = 32)

multi_disease_model.fit_generator(F_AP_gen, 
                                  steps_per_epoch=100,
                                  validation_data = (test_X_FAP, test_Y_FAP), 
                                  epochs = 1, 
                                  callbacks = callbacks_list1)

for c_label, s_count in zip(all_labels, 100*np.mean(test_Y_FAP,0)):
    print('%s: %2.2f%%' % (c_label, s_count))

pred_Y_FAP = multi_disease_model.predict(test_X_FAP, batch_size = 32, verbose = True)

from sklearn.metrics import roc_curve, auc
fig, c_ax = plt.subplots(1,1, figsize = (9, 9))
for (idx, c_label) in enumerate(all_labels):
    fpr, tpr, thresholds = roc_curve(test_Y_FAP[:,idx].astype(int), pred_Y_FAP[:,idx])
    c_ax.plot(fpr, tpr, label = '%s (AUC:%0.2f)'  % (c_label, auc(fpr, tpr)))
c_ax.legend()
c_ax.set_xlabel('False Positive Rate')
c_ax.set_ylabel('True Positive Rate')
fig.savefig('barely_trained_net.png')

"""End of subsetting FAP

###Start of MAP
"""

M = train_df.loc[train_df['Patient Gender'] == 'M']
M_AP = M.loc[M['View Position'] == 'AP']
valid_M = valid_df.loc[valid_df['Patient Gender'] == 'M']
valid_M_AP = valid_M.loc[valid_M['View Position'] == 'AP']

test_X_MAP, test_Y_MAP = next(flow_from_dataframe(core_idg, 
                               valid_M_AP, 
                             path_col = 'path',
                            y_col = 'disease_vec', 
                            target_size = IMG_SIZE,
                             color_mode = 'grayscale',
                            batch_size = 1024)) # one big batch

from keras.callbacks import ModelCheckpoint, LearningRateScheduler, EarlyStopping, ReduceLROnPlateau
weight_path2="{}_weights.best.hdf5".format('xray_class')

checkpoint2 = ModelCheckpoint(weight_path1, monitor='val_loss', verbose=1, 
                             save_best_only=True, mode='min', save_weights_only = True)

early2 = EarlyStopping(monitor="val_loss", 
                      mode="min", 
                      patience=3)
callbacks_list2 = [checkpoint2, early2]

M_AP_gen = flow_from_dataframe(core_idg, M_AP, 
                             path_col = 'path',
                            y_col = 'disease_vec', 
                            target_size = IMG_SIZE,
                             color_mode = 'grayscale',
                            batch_size = 32)

multi_disease_model.fit_generator(M_AP_gen, 
                                  steps_per_epoch=100,
                                  validation_data = (test_X_MAP, test_Y_MAP), 
                                  epochs = 1, 
                                  callbacks = callbacks_list1)

for c_label, s_count in zip(all_labels, 100*np.mean(test_Y_MAP,0)):
    print('%s: %2.2f%%' % (c_label, s_count))

pred_Y_MAP = multi_disease_model.predict(test_X_MAP, batch_size = 32, verbose = True)

from sklearn.metrics import roc_curve, auc
fig, c_ax = plt.subplots(1,1, figsize = (9, 9))
for (idx, c_label) in enumerate(all_labels):
    fpr, tpr, thresholds = roc_curve(test_Y_MAP[:,idx].astype(int), pred_Y_MAP[:,idx])
    c_ax.plot(fpr, tpr, label = '%s (AUC:%0.2f)'  % (c_label, auc(fpr, tpr)))
c_ax.legend()
c_ax.set_xlabel('False Positive Rate')
c_ax.set_ylabel('True Positive Rate')
fig.savefig('barely_trained_net.png')

"""End of MAP

### Start of FPA
"""

F_PA = F.loc[F['View Position'] == 'PA']
valid_F_PA = valid_F.loc[valid_F['View Position'] == 'PA']

test_X_FPA, test_Y_FPA = next(flow_from_dataframe(core_idg, 
                               valid_F_PA, 
                             path_col = 'path',
                            y_col = 'disease_vec', 
                            target_size = IMG_SIZE,
                             color_mode = 'grayscale',
                            batch_size = 1024)) # one big batch

from keras.callbacks import ModelCheckpoint, LearningRateScheduler, EarlyStopping, ReduceLROnPlateau
weight_path3="{}_weights.best.hdf5".format('xray_class')

checkpoint3 = ModelCheckpoint(weight_path1, monitor='val_loss', verbose=1, 
                             save_best_only=True, mode='min', save_weights_only = True)

early3 = EarlyStopping(monitor="val_loss", 
                      mode="min", 
                      patience=3)
callbacks_list3 = [checkpoint3, early3]

F_PA_gen = flow_from_dataframe(core_idg, F_PA, 
                             path_col = 'path',
                            y_col = 'disease_vec', 
                            target_size = IMG_SIZE,
                             color_mode = 'grayscale',
                            batch_size = 32)

multi_disease_model.fit_generator(F_PA_gen, 
                                  steps_per_epoch=100,
                                  validation_data = (test_X_FPA, test_Y_FPA), 
                                  epochs = 1, 
                                  callbacks = callbacks_list3)

for c_label, s_count in zip(all_labels, 100*np.mean(test_Y_FPA,0)):
    print('%s: %2.2f%%' % (c_label, s_count))

pred_Y_FPA = multi_disease_model.predict(test_X_FPA, batch_size = 32, verbose = True)

from sklearn.metrics import roc_curve, auc
fig, c_ax = plt.subplots(1,1, figsize = (9, 9))
for (idx, c_label) in enumerate(all_labels):
    fpr, tpr, thresholds = roc_curve(test_Y_FPA[:,idx].astype(int), pred_Y_FPA[:,idx])
    c_ax.plot(fpr, tpr, label = '%s (AUC:%0.2f)'  % (c_label, auc(fpr, tpr)))
c_ax.legend()
c_ax.set_xlabel('False Positive Rate')
c_ax.set_ylabel('True Positive Rate')
fig.savefig('barely_trained_net.png')

"""End of FPA

### Start of MPA
"""

M_PA = M.loc[M['View Position'] == 'PA']
valid_M_PA = valid_M.loc[valid_M['View Position'] == 'PA']

test_X_MPA, test_Y_MPA = next(flow_from_dataframe(core_idg, 
                               valid_M_PA, 
                             path_col = 'path',
                            y_col = 'disease_vec', 
                            target_size = IMG_SIZE,
                             color_mode = 'grayscale',
                            batch_size = 1024)) # one big batch

from keras.callbacks import ModelCheckpoint, LearningRateScheduler, EarlyStopping, ReduceLROnPlateau
weight_path4="{}_weights.best.hdf5".format('xray_class')

checkpoint4 = ModelCheckpoint(weight_path1, monitor='val_loss', verbose=1, 
                             save_best_only=True, mode='min', save_weights_only = True)

early4 = EarlyStopping(monitor="val_loss", 
                      mode="min", 
                      patience=3)
callbacks_list4 = [checkpoint4, early4]

M_PA_gen = flow_from_dataframe(core_idg, M_PA, 
                             path_col = 'path',
                            y_col = 'disease_vec', 
                            target_size = IMG_SIZE,
                             color_mode = 'grayscale',
                            batch_size = 32)

multi_disease_model.fit_generator(M_PA_gen, 
                                  steps_per_epoch=100,
                                  validation_data = (test_X_MPA, test_Y_MPA), 
                                  epochs = 1, 
                                  callbacks = callbacks_list4)

for c_label, s_count in zip(all_labels, 100*np.mean(test_Y_MPA,0)):
    print('%s: %2.2f%%' % (c_label, s_count))

pred_Y_MPA = multi_disease_model.predict(test_X_MPA, batch_size = 32, verbose = True)

from sklearn.metrics import roc_curve, auc
fig, c_ax = plt.subplots(1,1, figsize = (9, 9))
for (idx, c_label) in enumerate(all_labels):
    fpr, tpr, thresholds = roc_curve(test_Y_MPA[:,idx].astype(int), pred_Y_MPA[:,idx])
    c_ax.plot(fpr, tpr, label = '%s (AUC:%0.2f)'  % (c_label, auc(fpr, tpr)))
c_ax.legend()
c_ax.set_xlabel('False Positive Rate')
c_ax.set_ylabel('True Positive Rate')
fig.savefig('barely_trained_net.png')



"""End of MPA

### Continue of General
"""

for c_label, s_count in zip(all_labels, 100*np.mean(test_Y,0)):
    print('%s: %2.2f%%' % (c_label, s_count))

pred_Y = multi_disease_model.predict(test_X, batch_size = 32, verbose = True)

from sklearn.metrics import roc_curve, auc
fig, c_ax = plt.subplots(1,1, figsize = (9, 9))
for (idx, c_label) in enumerate(all_labels):
    fpr, tpr, thresholds = roc_curve(test_Y[:,idx].astype(int), pred_Y[:,idx])
    c_ax.plot(fpr, tpr, label = '%s (AUC:%0.2f)'  % (c_label, auc(fpr, tpr)))
c_ax.legend()
c_ax.set_xlabel('False Positive Rate')
c_ax.set_ylabel('True Positive Rate')
fig.savefig('barely_trained_net.png')

multi_disease_model.fit_generator(train_gen, 
                                  steps_per_epoch = 100,
                                  validation_data =  (test_X, test_Y), 
                                  epochs = 0, 
                                  callbacks = callbacks_list)

# load the best weights
multi_disease_model.load_weights(weight_path)

pred_Y = multi_disease_model.predict(test_X, batch_size = 32, verbose = True)

# look at how often the algorithm predicts certain diagnoses 
for c_label, p_count, t_count in zip(all_labels, 
                                     100*np.mean(pred_Y,0), 
                                     100*np.mean(test_Y,0)):
    print('%s: Dx: %2.2f%%, PDx: %2.2f%%' % (c_label, t_count, p_count))

from sklearn.metrics import roc_curve, auc
fig, c_ax = plt.subplots(1,1, figsize = (9, 9))
for (idx, c_label) in enumerate(all_labels):
    fpr, tpr, thresholds = roc_curve(test_Y[:,idx].astype(int), pred_Y[:,idx])
    c_ax.plot(fpr, tpr, label = '%s (AUC:%0.2f)'  % (c_label, auc(fpr, tpr)))
c_ax.legend()
c_ax.set_xlabel('False Positive Rate')
c_ax.set_ylabel('True Positive Rate')
fig.savefig('trained_net.png')

sickest_idx = np.argsort(np.sum(test_Y, 1)<1)
fig, m_axs = plt.subplots(4, 2, figsize = (16, 32))
for (idx, c_ax) in zip(sickest_idx, m_axs.flatten()):
    c_ax.imshow(test_X[idx, :,:,0], cmap = 'bone')
    stat_str = [n_class[:6] for n_class, n_score in zip(all_labels, 
                                                                  test_Y[idx]) 
                             if n_score>0.5]
    pred_str = ['%s:%2.0f%%' % (n_class[:4], p_score*100)  for n_class, n_score, p_score in zip(all_labels, 
                                                                  test_Y[idx], pred_Y[idx]) 
                             if (n_score>0.5) or (p_score>0.5)]
    c_ax.set_title('Dx: '+', '.join(stat_str)+'\nPDx: '+', '.join(pred_str))
    c_ax.axis('off')
fig.savefig('trained_img_predictions.png')